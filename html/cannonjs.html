<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Three.js + Cannon.js Physics</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
  </style>
</head>
<body>
  <script type="module">
    import * as THREE from './libs/three.module.js';
    import { OrbitControls } from './libs/OrbitControls.js';
    import * as CANNON from './libs/cannon-es.js';

    let scene, camera, renderer, controls;
    let world, cube, ground, sphere, light;
    let cubeBody, sphereBody;

    // Initialize Three.js scene
    function setupScene() {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(5, 5, 10);

      // Renderer
      renderer = new THREE.WebGLRenderer();
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // OrbitControls
      controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.25;
      controls.enableZoom = true;

      // Lighting
      light = new THREE.PointLight(0xFFFFFF, 1, 100);
      light.position.set(5, 5, 5);
      scene.add(light);
    }

    // Set up the physics world using Cannon.js
    function setupPhysics() {
      world = new CANNON.World();
      world.gravity.set(0, -9.82, 0); // Gravity
      world.broadphase = new CANNON.NaiveBroadphase(); // Broadphase algorithm
      world.solver.iterations = 10; // Solver iterations

      // Create ground (static body)
      const groundMaterial = new CANNON.Material();
      const groundShape = new CANNON.Plane();
      ground = new CANNON.Body({
        mass: 0, // Static body
        position: new CANNON.Vec3(0, -5, 0),
        shape: groundShape,
        material: groundMaterial
      });
      world.addBody(ground);

      // Create the cube (dynamic body)
      const cubeMaterial = new CANNON.Material();
      const cubeShape = new CANNON.Box(new CANNON.Vec3(1, 1, 1)); // 1x1x1 box
      cubeBody = new CANNON.Body({
        mass: 1, // Dynamic body
        position: new CANNON.Vec3(0, 5, 0), // Starting position
        material: cubeMaterial
      });
      cubeBody.addShape(cubeShape);
      world.addBody(cubeBody);

      // Create the sphere (dynamic body)
      const sphereMaterial = new CANNON.Material();
      const sphereShape = new CANNON.Sphere(1); // Radius 1 sphere
      sphereBody = new CANNON.Body({
        mass: 1, // Dynamic body
        position: new CANNON.Vec3(3, 10, 0),
        material: sphereMaterial
      });
      sphereBody.addShape(sphereShape);
      world.addBody(sphereBody);
    }

    // Create Three.js objects (cube, sphere, and ground)
    function createObjects() {
      // Ground
      const groundGeometry = new THREE.PlaneGeometry(100, 100);
      const groundMaterial = new THREE.ShadowMaterial({ opacity: 0.5 });
      const groundMesh = new THREE.Mesh(groundGeometry, groundMaterial);
      groundMesh.rotation.x = -Math.PI / 2;
      scene.add(groundMesh);

      // Cube
      const cubeGeometry = new THREE.BoxGeometry(2, 2, 2);
      const cubeMaterial = new THREE.MeshLambertMaterial({ color: 0x00ff00 });
      cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
      cube.castShadow = true;
      scene.add(cube);

      // Sphere
      const sphereGeometry = new THREE.SphereGeometry(1);
      const sphereMaterial = new THREE.MeshLambertMaterial({ color: 0x0000ff });
      sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
      sphere.castShadow = true;
      scene.add(sphere);
    }

    // Update the physics and Three.js objects
    function updatePhysics() {
      world.step(1 / 60); // Update physics world

      // Sync the cube and sphere's position and rotation with their physics bodies
      cube.position.copy(cubeBody.position);
      cube.rotation.set(cubeBody.rotation.x, cubeBody.rotation.y, cubeBody.rotation.z);

      sphere.position.copy(sphereBody.position);
      sphere.rotation.set(sphereBody.rotation.x, sphereBody.rotation.y, sphereBody.rotation.z);
    }

    // Handle window resize
    function onWindowResize() {
      renderer.setSize(window.innerWidth, window.innerHeight);
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
    }

    // Animation loop
    function animate() {
      requestAnimationFrame(animate);

      controls.update(); // Update the controls (for smooth movement)
      updatePhysics(); // Update the physics

      renderer.render(scene, camera);
    }

    // Initialize everything
    function init() {
      setupScene();
      setupPhysics();
      createObjects();
      window.addEventListener('resize', onWindowResize, false);
      animate();
    }

    // Start the app
    init();
  </script>
</body>
</html>
